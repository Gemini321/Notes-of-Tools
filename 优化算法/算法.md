# 优化算法

## 模拟退火（Simulated Annealing）

<strong>
<font size=4 color="red">模拟退火算法用于求解全局最优解或近似全局最优解。</font>
</strong>

模拟退火算法来源于晶体冷却的过程，如果固体不处于最低能量状态，给固体加热再
冷却，随着温度缓慢下降，固体中的原子按照一定形状排列，形成高密度、低能量的
有规则晶体，对应于算法中的全局最优解。而如果温度下降过快，可能导致原子缺少
足够的时间排列成晶体的结构，结果产生了具有较高能量的非晶体，这就是局部最优
解。因此就可以根据退火的过程，给其在增加一点能量，然后在冷却，如果增加
能量，跳出了局部最优解，这本次退火就是成功的。

<div align="center">
<img src="https://img-blog.csdnimg.cn/20181113184137197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="晶体退火图解" style="zoom:67%;" />
</div>

根据上述解释，可以抽象出数学公式：

<div align="center">
<img src="https://private.codecogs.com/gif.latex?%5Cdpi%7B120%7D%20P%20%3D%20%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%201%2C%20E%28n&plus;1%29%3CE%28n%29%26%20%5C%5C%20%26%20%5C%5C%20%26%20%5C%5C%20e%5E%7B-%5Cfrac%7BE%28n&plus;1%29%20-%20E%28n%29%7D%7BT%7D%7D%2C%20E%28n&plus;1%29%20%5Cgeq%20E%28n%29%26%20%5Cend%7Bmatrix%7D%5Cright." alt="接受概率P" style="zoom:80%;" />
</div>

上述公式的可调参数为T，当T过大时，导致收敛速度过快；当T过小，导致收敛
速度过低，计算量过大。因此一般在退火初期使用较大的T值，T值随着退火的进行
而逐渐下降，直到达到终止温度。常用的退火速率如下：

* 指数式下降：$T(n + 1) = \lambda T(n)$，$\lambda$一般取
$[0.8, 0.99]$，收敛比较慢
* 其他方式：$T(n + 1) = \frac{T(0)}{log_2(1 + t)}$，
$T(N) = \frac{T(0)}{1 + t}$

综上所述：模拟退火可以分解为解空间、目标函数和初始解三部分，流程如下：

1. 初始化：初始化温度$T$，初始解状态$S$，以及$T$值的迭代次数$L$（或终止温度）
2. 使用其他算法产生新解$S'$，并计算增量$\Delta T = C(S') - C(S)$，
其中C(x)为代价函数
3. 若$\Delta T < 0$，接受新解；若$\Delta T \geq 0$，以概率
$P = e ^ {\frac{\Delta T}{T}}$接受新解
4. 若满足输出条件则输出当前解为最优解，并结束程序；否则重复步骤2, 3
条件一般为连续多个新解都没有被接受
5. 当$T$达到预设温度时，结束算法

<div align="center">
<img src="https://img-blog.csdnimg.cn/20181113204754673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="模拟退火流程图" style="zoom:100%;" />
</div>

## 蚁群算法（Ant colony algorithm）

蚁群算法就是模拟蚂蚁寻找食物的过程，它能够求出从原点出发，经过若干个给定的
需求点，最终返回原点的最短路径。该算法可以用于解决分布式环境下的
负载均衡调度问题，该问题描述如下：

> 求一种最优的任务分配策略，能够将N个长度不等的任务按照某一种策略分配给M个处理能力不同的服务器节点，并且N个任务的完成时间最短。

### 算法介绍

蚂蚁在行走过程中会释放一种称为“信息素”的物质，用来标识自己的行走路径。在寻
找食物的过程中，根据信息素的浓度选择行走的方向，并最终到达食物所在的地方。
而信息素会随着时间的推移而逐渐挥发。

在一开始的时候，由于地面上没有信息素，因此蚂蚁们的行走路径是随机的。蚂蚁们
在行走的过程中会不断释放信息素，标识自己的行走路径。随着时间的推移，有若干
只蚂蚁找到了食物，此时便存在若干条从洞穴到食物的路径。由于蚂蚁的行为轨迹是
随机分布的，因此在单位时间内，短路径上蚂蚁留下的信息素浓度较高，这为后面的蚂
蚁们提供了强有力的方向指引（正反馈），越来越多的蚂蚁聚集到最短的路径上去。

## 遗传算法（Genetic Algorithm）

开始时我们对现有特征进行编码（一般用二进制编码简化后续计算），生成初代
种群的基因库。再定义自适应度函数f(x)，根据f(x)判断该个体的自适应度。
初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生
出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择
（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行
<font color="red">组合交叉（crossover）和变异（mutation）</font>，产生出代表新的解集的种群。

这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境（正反馈），
末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。
其优点是我们无需确定如何走向最优点，只需将不好的结果否定即可。

<div align=center>
<img src="https://upload-images.jianshu.io/upload_images/10386940-f6a0d1d8226405fa.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/708" alt="遗传算法流程图" style="zoom:70%"/>
</div>

### 编码

编码方法可以分为三大类：二进制编码法、浮点编码法、符号编码法。

#### 二进制编码法

二进制编码法相当于只有0-1对的DNA序列，当DNA足够长时，可以表示所需要的
所有特征。优点是简单，计算快捷；缺点是对于连续函数的优化支持不佳，
对于一些高精度问题，在解迫近于最优解时，容易因为0-1的不连续变化导致突变。

#### 浮点编码法

所谓浮点法，是指个体的每个基因值用某一范围内的一个浮点数来表示。在浮点数编码
方法中，必须保证基因值在给定的区间限制范围内，遗传算法中所使用的交叉、变异等
遗传算子也必须保证其运算结果所产生的新个体的基因值也在这个区间限制范围内。

该方法的优点为范围大、精度高、对连续变化的特征支持较好。

#### 符号编码法

符号编码法是指个体染色体编码串中的基因值取自一个无数值含义、而只有代码含义的
符号集如｛A,B,C…｝。优点为可以在遗传算法中利用其他领域的知识求解问题，缺点
是需要为符号的变化设置相应的规则。

进行编码时需要尽可能减少无关变量的数量，将相关变量合理映射到编码中，建立
基因型到表现型的映射关系，同时要保证能从编码中译码得到原始信息，便于
使用自适应函数求值。

### 自适应函数

自适应函数总是非负的，其结果反映了该基因型对目标环境的适应程度。
而目标函数则有正有负（例如海拔高度），我们需要对目标函数到自适应函数
之间作一些变换。

### 选择函数

遗传算法中的选择操作就是用来确定如何从父代群体中按某种方法选取那些个体，以便
遗传到下一代群体。选择操作用来<font color="red">确定重组或交叉个体，以及被选个体将产生多少个子代个体。</font>

常用的选择算子：

* 轮盘赌选择（Roulette Wheel Selection）：一种回放式随机采样方法。每个个体
进入下一代的概率等于它的适应度值与整个种群中个体适应度值和的比例。选择误差较
大。
* 随机竞争选择（Stochastic Tournament）：每次按轮盘赌选择一对个体，然后让
这两个个体进行竞争，适应度高的被选中，如此反复，直到选满为止。
* 最佳保留选择：首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中
适应度最高的个体结构完整地复制到下一代群体中。
* 无回放随机选择（也叫期望值选择Excepted Value Selection）：根据每个个体在
下一代群体中的生存期望来进行随机选择运算。

### 遗传（染色体交叉 Crossover）

遗传算法的交叉操作，是指对两个相互配对的染色体按某种方式相互交换其部分基因，
从而形成两个新的个体。

对于二进制编码，我们有如下交叉算子：

* 单点交叉（One-point Crossover）：指在个体编码串中只随机设置一个交叉点
（着丝点），然后再该点相互交换两个配对个体的部分染色体。
* 多点交叉（Multi-point Crossover）：染色体的交叉互换
* 均匀交叉（也称一致交叉，Uniform Crossover）：两个配对个体的每个基因座上的
基因都以相同的交叉概率进行交换，从而形成两个新个体。
* 算术交叉（Arithmetic Crossover）：由两个个体的线性组合而产生出两个新的个
体。该操作对象一般是由浮点数编码表示的个体。

### 变异（基因突变 Mutation）

遗传算法中的变异运算，是指将个体染色体编码串中的某些基因座上的基因值用该基因
座上的其它等位基因来替换，从而形成新的个体。

## 粒子群优化算法（Partical Swarm Optimization）

## 禁忌搜索（Tabu Search, TS）

禁忌搜索算法是一种元启发式(meta-heuristic)随机搜索算法，它从一个初始可行解
出发，选择一系列的特定搜索方向（移动）作为试探，选择实现让特定的目标函数值变
化最多的移动。为了避免陷入局部最优解，TS搜索中采用了一种灵活的“记忆”技术，对
已经进行的优化过程进行记录和选择，指导下一步的搜索方向，这就是Tabu表的建立。

比喻：兔子们找到了泰山，它们之中的一只就会留守在这里，其他的再去别的地方寻
找。就这样，一大圈后，把找到的几个山峰一比较，珠穆朗玛峰脱颖而出。

### 相关概念

* 邻域：对于给定点，能够通过一定规则通过一步操作转化得到的所有点的集合
* 邻域动作：一个状态转移函数，能够以一个状态作为输入，输出该状态的邻域
* 禁忌表：包括禁忌对象和禁忌长度，用来确认已经搜索过的区域
* 候选集合：满足候选条件的邻域的状态集合
* 禁忌对象：避免再次到达的状态
* 禁忌长度：禁忌对象保存在禁忌表的最长时间，到达禁忌长度后将该禁忌对象删除
* 评价函数：选取候选集合的函数，目标值应当是一个直观的判断指标
* 特赦规则：候选集合中的所有元素都被禁忌，考虑将这些元素中最优的元素取出禁忌
表
